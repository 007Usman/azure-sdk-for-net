// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
// 
// Code generated by Microsoft (R) AutoRest Code Generator 0.13.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

namespace Microsoft.Azure.Management.DataLake.Store
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Rest;
    using Microsoft.Rest.Azure;
    using Models;

    public static partial class DataLakeStoreFileSystemOperationsExtensions
    {
            /// <summary>
            /// Appends to the file specified. This method supports multiple concurrent
            /// appends to the file. NOTE: that concurrent append and serial append
            /// CANNOT be used interchangeably. Once a file has been appended to using
            /// either one, it can only be appended to using that type of append.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the data lake account that the file lives in.
            /// </param>
            /// <param name='filePath'>
            /// The path to the file to append to using concurrent append.
            /// </param>
            /// <param name='streamContents'>
            /// The file contents to include when appending to the file.
            /// </param>
            /// <param name='op'>
            /// </param>
            public static void ConcurrentAppend(this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, byte[] streamContents, string op = "concurrentappend")
            {
                Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).ConcurrentAppendAsync(accountName, filePath, streamContents, op), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Appends to the file specified. This method supports multiple concurrent
            /// appends to the file. NOTE: that concurrent append and serial append
            /// CANNOT be used interchangeably. Once a file has been appended to using
            /// either one, it can only be appended to using that type of append.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the data lake account that the file lives in.
            /// </param>
            /// <param name='filePath'>
            /// The path to the file to append to using concurrent append.
            /// </param>
            /// <param name='streamContents'>
            /// The file contents to include when appending to the file.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task ConcurrentAppendAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, byte[] streamContents, string op = "concurrentappend", CancellationToken cancellationToken = default(CancellationToken))
            {
                await operations.ConcurrentAppendWithHttpMessagesAsync(accountName, filePath, streamContents, op, null, cancellationToken).ConfigureAwait(false);
            }

            /// <summary>
            /// Checks if the specified access is available at the given path.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='path'>
            /// The path to the file or folder to check access for.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='fsaction'>
            /// File system operation read/write/execute in string form, matching regex
            /// pattern '[rwx-]{3}'
            /// </param>
            public static void CheckAccess(this IDataLakeStoreFileSystemOperations operations, string accountName, string path, string op = "CHECKACCESS", string fsaction = default(string))
            {
                Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).CheckAccessAsync(accountName, path, op, fsaction), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Checks if the specified access is available at the given path.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='path'>
            /// The path to the file or folder to check access for.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='fsaction'>
            /// File system operation read/write/execute in string form, matching regex
            /// pattern '[rwx-]{3}'
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task CheckAccessAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string path, string op = "CHECKACCESS", string fsaction = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                await operations.CheckAccessWithHttpMessagesAsync(accountName, path, op, fsaction, null, cancellationToken).ConfigureAwait(false);
            }

            /// <summary>
            /// Creates a directory.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='path'>
            /// The path to the directory to create.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='permission'>
            /// The optional permissions to set on the directories
            /// </param>
            public static FileOperationResultResult Mkdirs(this IDataLakeStoreFileSystemOperations operations, string accountName, string path, string op = "MKDIRS", string permission = default(string))
            {
                return Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).MkdirsAsync(accountName, path, op, permission), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Creates a directory.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='path'>
            /// The path to the directory to create.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='permission'>
            /// The optional permissions to set on the directories
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<FileOperationResultResult> MkdirsAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string path, string op = "MKDIRS", string permission = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                AzureOperationResponse<FileOperationResultResult> result = await operations.MkdirsWithHttpMessagesAsync(accountName, path, op, permission, null, cancellationToken).ConfigureAwait(false);
                return result.Body;
            }

            /// <summary>
            /// Concatenates the list of files into the target file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='destinationPath'>
            /// The path to the destination file resulting from the concatenation.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='sources'>
            /// A list of comma seperated absolute FileSystem paths without scheme and
            /// authority
            /// </param>
            public static void Concat(this IDataLakeStoreFileSystemOperations operations, string accountName, string destinationPath, string op = "CONCAT", string sources = default(string))
            {
                Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).ConcatAsync(accountName, destinationPath, op, sources), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Concatenates the list of files into the target file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='destinationPath'>
            /// The path to the destination file resulting from the concatenation.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='sources'>
            /// A list of comma seperated absolute FileSystem paths without scheme and
            /// authority
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task ConcatAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string destinationPath, string op = "CONCAT", string sources = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                await operations.ConcatWithHttpMessagesAsync(accountName, destinationPath, op, sources, null, cancellationToken).ConfigureAwait(false);
            }

            /// <summary>
            /// Directly appends to a file with the specified content, without requiring a
            /// redirect. This API is NOT webhdfs compliant. It should be used only by
            /// tools that do not rely on webhdfs interoperability.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the Data Lake Store account to append to the file in
            /// </param>
            /// <param name='filePath'>
            /// The path to the file to append to.
            /// </param>
            /// <param name='streamContents'>
            /// The file contents to include when appending to the file.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='buffersize'>
            /// The optional buffer size to use when appending data
            /// </param>
            public static FileCreateOpenAndAppendResult DirectAppend(this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, byte[] streamContents, string op = "APPEND", long? buffersize = default(long?))
            {
                return Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).DirectAppendAsync(accountName, filePath, streamContents, op, buffersize), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Directly appends to a file with the specified content, without requiring a
            /// redirect. This API is NOT webhdfs compliant. It should be used only by
            /// tools that do not rely on webhdfs interoperability.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the Data Lake Store account to append to the file in
            /// </param>
            /// <param name='filePath'>
            /// The path to the file to append to.
            /// </param>
            /// <param name='streamContents'>
            /// The file contents to include when appending to the file.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='buffersize'>
            /// The optional buffer size to use when appending data
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<FileCreateOpenAndAppendResult> DirectAppendAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, byte[] streamContents, string op = "APPEND", long? buffersize = default(long?), CancellationToken cancellationToken = default(CancellationToken))
            {
                AzureOperationResponse<FileCreateOpenAndAppendResult> result = await operations.DirectAppendWithHttpMessagesAsync(accountName, filePath, streamContents, op, buffersize, null, cancellationToken).ConfigureAwait(false);
                return result.Body;
            }

            /// <summary>
            /// Removes the existing ACL on a file or folder.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='filePath'>
            /// The path to the directory or file to remove ACL on.
            /// </param>
            /// <param name='op'>
            /// </param>
            public static void RemoveAcl(this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, string op = "REMOVEACL")
            {
                Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).RemoveAclAsync(accountName, filePath, op), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Removes the existing ACL on a file or folder.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='filePath'>
            /// The path to the directory or file to remove ACL on.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task RemoveAclAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, string op = "REMOVEACL", CancellationToken cancellationToken = default(CancellationToken))
            {
                await operations.RemoveAclWithHttpMessagesAsync(accountName, filePath, op, null, cancellationToken).ConfigureAwait(false);
            }

            /// <summary>
            /// Gets ACL entries on a file or folder.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='filePath'>
            /// The path to the directory or file to get ACLs on.
            /// </param>
            /// <param name='op'>
            /// </param>
            public static AclStatusResult GetAclStatus(this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, string op = "GETACLSTATUS")
            {
                return Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).GetAclStatusAsync(accountName, filePath, op), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets ACL entries on a file or folder.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='filePath'>
            /// The path to the directory or file to get ACLs on.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<AclStatusResult> GetAclStatusAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, string op = "GETACLSTATUS", CancellationToken cancellationToken = default(CancellationToken))
            {
                AzureOperationResponse<AclStatusResult> result = await operations.GetAclStatusWithHttpMessagesAsync(accountName, filePath, op, null, cancellationToken).ConfigureAwait(false);
                return result.Body;
            }

            /// <summary>
            /// Deletes the requested file or folder, optionally recursively.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='filePath'>
            /// The path to the file or folder to delete.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='recursive'>
            /// The optional switch indicating if the delete should be recursive
            /// </param>
            public static FileOperationResultResult Delete(this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, string op = "DELETE", bool? recursive = default(bool?))
            {
                return Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).DeleteAsync(accountName, filePath, op, recursive), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Deletes the requested file or folder, optionally recursively.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='filePath'>
            /// The path to the file or folder to delete.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='recursive'>
            /// The optional switch indicating if the delete should be recursive
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<FileOperationResultResult> DeleteAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string filePath, string op = "DELETE", bool? recursive = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
            {
                AzureOperationResponse<FileOperationResultResult> result = await operations.DeleteWithHttpMessagesAsync(accountName, filePath, op, recursive, null, cancellationToken).ConfigureAwait(false);
                return result.Body;
            }

            /// <summary>
            /// Appends to the file specified in the link that was returned from
            /// BeginAppend.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fileAppendRequestLink'>
            /// The link to the file to append to including all required parameters.
            /// </param>
            /// <param name='streamContents'>
            /// The file contents to include when appending to the file.
            /// </param>
            public static void Append(this IDataLakeStoreFileSystemOperations operations, string fileAppendRequestLink, byte[] streamContents)
            {
                Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).AppendAsync(fileAppendRequestLink, streamContents), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Appends to the file specified in the link that was returned from
            /// BeginAppend.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fileAppendRequestLink'>
            /// The link to the file to append to including all required parameters.
            /// </param>
            /// <param name='streamContents'>
            /// The file contents to include when appending to the file.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task AppendAsync( this IDataLakeStoreFileSystemOperations operations, string fileAppendRequestLink, byte[] streamContents, CancellationToken cancellationToken = default(CancellationToken))
            {
                await operations.AppendWithHttpMessagesAsync(fileAppendRequestLink, streamContents, null, cancellationToken).ConfigureAwait(false);
            }

            /// <summary>
            /// Sets the access or modification time on a file or folder.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='sourcePath'>
            /// The path to the directory or file to set permissions on.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='modificationtime'>
            /// The modification time of a file/directory. If -1 remains unchanged
            /// </param>
            /// <param name='accesstime'>
            /// The access time of a file/directory. If -1 remains unchanged
            /// </param>
            public static void SetTimes(this IDataLakeStoreFileSystemOperations operations, string accountName, string sourcePath, string op = "SETTIMES", long? modificationtime = default(long?), long? accesstime = default(long?))
            {
                Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).SetTimesAsync(accountName, sourcePath, op, modificationtime, accesstime), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Sets the access or modification time on a file or folder.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='sourcePath'>
            /// The path to the directory or file to set permissions on.
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='modificationtime'>
            /// The modification time of a file/directory. If -1 remains unchanged
            /// </param>
            /// <param name='accesstime'>
            /// The access time of a file/directory. If -1 remains unchanged
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task SetTimesAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string sourcePath, string op = "SETTIMES", long? modificationtime = default(long?), long? accesstime = default(long?), CancellationToken cancellationToken = default(CancellationToken))
            {
                await operations.SetTimesWithHttpMessagesAsync(accountName, sourcePath, op, modificationtime, accesstime, null, cancellationToken).ConfigureAwait(false);
            }

            /// <summary>
            /// Get the home directory for the specified account.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='op'>
            /// </param>
            public static HomeDirectoryResult GetHomeDirectory(this IDataLakeStoreFileSystemOperations operations, string accountName, string op = "GETHOMEDIRECTORY")
            {
                return Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).GetHomeDirectoryAsync(accountName, op), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Get the home directory for the specified account.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='accountName'>
            /// The name of the account to use
            /// </param>
            /// <param name='op'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<HomeDirectoryResult> GetHomeDirectoryAsync( this IDataLakeStoreFileSystemOperations operations, string accountName, string op = "GETHOMEDIRECTORY", CancellationToken cancellationToken = default(CancellationToken))
            {
                AzureOperationResponse<HomeDirectoryResult> result = await operations.GetHomeDirectoryWithHttpMessagesAsync(accountName, op, null, cancellationToken).ConfigureAwait(false);
                return result.Body;
            }

            /// <summary>
            /// Creates the file specified in the link that was returned from BeginCreate.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fileCreateRequestLink'>
            /// The link to the file to create including all required parameters.
            /// </param>
            /// <param name='streamContents'>
            /// The file contents to include when creating the file. This parameter is
            /// required, however it can be an empty stream. Just not null.
            /// </param>
            public static void Create(this IDataLakeStoreFileSystemOperations operations, string fileCreateRequestLink, byte[] streamContents)
            {
                Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).CreateAsync(fileCreateRequestLink, streamContents), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Creates the file specified in the link that was returned from BeginCreate.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fileCreateRequestLink'>
            /// The link to the file to create including all required parameters.
            /// </param>
            /// <param name='streamContents'>
            /// The file contents to include when creating the file. This parameter is
            /// required, however it can be an empty stream. Just not null.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task CreateAsync( this IDataLakeStoreFileSystemOperations operations, string fileCreateRequestLink, byte[] streamContents, CancellationToken cancellationToken = default(CancellationToken))
            {
                await operations.CreateWithHttpMessagesAsync(fileCreateRequestLink, streamContents, null, cancellationToken).ConfigureAwait(false);
            }

            /// <summary>
            /// Gets the data associated with the file handle requested.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fileOpenRequestLink'>
            /// The link to the file to open including all required parameters.
            /// </param>
            public static System.IO.Stream Open(this IDataLakeStoreFileSystemOperations operations, string fileOpenRequestLink)
            {
                return Task.Factory.StartNew(s => ((IDataLakeStoreFileSystemOperations)s).OpenAsync(fileOpenRequestLink), operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets the data associated with the file handle requested.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fileOpenRequestLink'>
            /// The link to the file to open including all required parameters.
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<System.IO.Stream> OpenAsync( this IDataLakeStoreFileSystemOperations operations, string fileOpenRequestLink, CancellationToken cancellationToken = default(CancellationToken))
            {
                AzureOperationResponse<System.IO.Stream> result = await operations.OpenWithHttpMessagesAsync(fileOpenRequestLink, null, cancellationToken).ConfigureAwait(false);
                return result.Body;
            }

    }
}
