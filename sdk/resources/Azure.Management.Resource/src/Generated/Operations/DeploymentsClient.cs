// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Management.Resource.Models;

namespace Azure.Management.Resource
{
    /// <summary> The Deployments service client. </summary>
    public partial class DeploymentsClient
    {
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly HttpPipeline _pipeline;
        internal DeploymentsRestClient RestClient { get; }
        /// <summary> Initializes a new instance of DeploymentsClient for mocking. </summary>
        protected DeploymentsClient()
        {
        }

        /// <summary> Initializes a new instance of DeploymentsClient. </summary>
        public DeploymentsClient(string subscriptionId, TokenCredential tokenCredential, ResourceManagementClientOptions options = null)
        {
            options ??= new ResourceManagementClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _pipeline = ManagementPipelineBuilder.Build(tokenCredential, options);
            RestClient = new DeploymentsRestClient(_clientDiagnostics, _pipeline, subscriptionId: subscriptionId);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CheckExistenceAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistenceAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CheckExistenceAtScope(scope, deploymentName, cancellationToken);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.GetAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> GetAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.GetAtScope(scope, deploymentName, cancellationToken);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CancelAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CancelAtScope(scope, deploymentName, cancellationToken);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.ExportTemplateAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplateAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.ExportTemplateAtScope(scope, deploymentName, cancellationToken);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CheckExistenceAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistenceAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CheckExistenceAtTenantScope(deploymentName, cancellationToken);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.GetAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> GetAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.GetAtTenantScope(deploymentName, cancellationToken);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CancelAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CancelAtTenantScope(deploymentName, cancellationToken);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.ExportTemplateAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplateAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.ExportTemplateAtTenantScope(deploymentName, cancellationToken);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CheckExistenceAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistenceAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CheckExistenceAtManagementGroupScope(groupId, deploymentName, cancellationToken);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.GetAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> GetAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.GetAtManagementGroupScope(groupId, deploymentName, cancellationToken);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CancelAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CancelAtManagementGroupScope(groupId, deploymentName, cancellationToken);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.ExportTemplateAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplateAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.ExportTemplateAtManagementGroupScope(groupId, deploymentName, cancellationToken);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CheckExistenceAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistenceAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CheckExistenceAtSubscriptionScope(deploymentName, cancellationToken);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.GetAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> GetAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.GetAtSubscriptionScope(deploymentName, cancellationToken);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CancelAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CancelAtSubscriptionScope(deploymentName, cancellationToken);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.ExportTemplateAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplateAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.ExportTemplateAtSubscriptionScope(deploymentName, cancellationToken);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployment to check. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CheckExistenceAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployment to check. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistence(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.CheckExistence(resourceGroupName, deploymentName, cancellationToken);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.GetAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> Get(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.Get(resourceGroupName, deploymentName, cancellationToken);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.CancelAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response Cancel(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.Cancel(resourceGroupName, deploymentName, cancellationToken);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            return await RestClient.ExportTemplateAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplate(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            return RestClient.ExportTemplate(resourceGroupName, deploymentName, cancellationToken);
        }

        /// <summary> Calculate the hash of the given template. </summary>
        /// <param name="template"> The template provided to calculate hash. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<TemplateHashResult>> CalculateTemplateHashAsync(object template, CancellationToken cancellationToken = default)
        {
            return await RestClient.CalculateTemplateHashAsync(template, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Calculate the hash of the given template. </summary>
        /// <param name="template"> The template provided to calculate hash. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<TemplateHashResult> CalculateTemplateHash(object template, CancellationToken cancellationToken = default)
        {
            return RestClient.CalculateTemplateHash(template, cancellationToken);
        }

        /// <summary> Get all the deployments at the given scope. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListAtScopeAsync(string scope, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }

            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                var response = await RestClient.ListAtScopeAsync(scope, filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = await RestClient.ListAtScopeNextPageAsync(nextLink, scope, filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments at the given scope. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListAtScope(string scope, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }

            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                var response = RestClient.ListAtScope(scope, filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = RestClient.ListAtScopeNextPage(nextLink, scope, filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments at the tenant scope. </summary>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListAtTenantScopeAsync(string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                var response = await RestClient.ListAtTenantScopeAsync(filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = await RestClient.ListAtTenantScopeNextPageAsync(nextLink, filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments at the tenant scope. </summary>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListAtTenantScope(string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                var response = RestClient.ListAtTenantScope(filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = RestClient.ListAtTenantScopeNextPage(nextLink, filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a management group. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListAtManagementGroupScopeAsync(string groupId, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }

            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                var response = await RestClient.ListAtManagementGroupScopeAsync(groupId, filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = await RestClient.ListAtManagementGroupScopeNextPageAsync(nextLink, groupId, filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a management group. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListAtManagementGroupScope(string groupId, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }

            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                var response = RestClient.ListAtManagementGroupScope(groupId, filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = RestClient.ListAtManagementGroupScopeNextPage(nextLink, groupId, filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a subscription. </summary>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListAtSubscriptionScopeAsync(string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                var response = await RestClient.ListAtSubscriptionScopeAsync(filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = await RestClient.ListAtSubscriptionScopeNextPageAsync(nextLink, filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a subscription. </summary>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListAtSubscriptionScope(string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                var response = RestClient.ListAtSubscriptionScope(filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = RestClient.ListAtSubscriptionScopeNextPage(nextLink, filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a resource group. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployments to get. The name is case insensitive. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListByResourceGroupAsync(string resourceGroupName, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }

            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                var response = await RestClient.ListByResourceGroupAsync(resourceGroupName, filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = await RestClient.ListByResourceGroupNextPageAsync(nextLink, resourceGroupName, filter, top, cancellationToken).ConfigureAwait(false);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a resource group. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployments to get. The name is case insensitive. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListByResourceGroup(string resourceGroupName, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }

            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                var response = RestClient.ListByResourceGroup(resourceGroupName, filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                var response = RestClient.ListByResourceGroupNextPage(nextLink, resourceGroupName, filter, top, cancellationToken);
                return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAtScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Delete, "DeploymentsClient.DeleteAtScope", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = await RestClient.DeleteAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
            return CreateDeleteAtScope(originalResponse, () => RestClient.CreateDeleteAtScopeRequest(scope, deploymentName));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = RestClient.DeleteAtScope(scope, deploymentName, cancellationToken);
            return CreateDeleteAtScope(originalResponse, () => RestClient.CreateDeleteAtScopeRequest(scope, deploymentName));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentExtended> CreateCreateOrUpdateAtScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Put, "DeploymentsClient.CreateOrUpdateAtScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            });
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentExtended>> StartCreateOrUpdateAtScopeAsync(string scope, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.CreateOrUpdateAtScopeAsync(scope, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateCreateOrUpdateAtScope(originalResponse, () => RestClient.CreateCreateOrUpdateAtScopeRequest(scope, deploymentName, parameters));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentExtended> StartCreateOrUpdateAtScope(string scope, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.CreateOrUpdateAtScope(scope, deploymentName, parameters, cancellationToken);
            return CreateCreateOrUpdateAtScope(originalResponse, () => RestClient.CreateCreateOrUpdateAtScopeRequest(scope, deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentValidateResult> CreateValidateAtScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Post, "DeploymentsClient.ValidateAtScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            });
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentValidateResult>> StartValidateAtScopeAsync(string scope, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.ValidateAtScopeAsync(scope, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateValidateAtScope(originalResponse, () => RestClient.CreateValidateAtScopeRequest(scope, deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentValidateResult> StartValidateAtScope(string scope, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.ValidateAtScope(scope, deploymentName, parameters, cancellationToken);
            return CreateValidateAtScope(originalResponse, () => RestClient.CreateValidateAtScopeRequest(scope, deploymentName, parameters));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAtTenantScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Delete, "DeploymentsClient.DeleteAtTenantScope", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = await RestClient.DeleteAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            return CreateDeleteAtTenantScope(originalResponse, () => RestClient.CreateDeleteAtTenantScopeRequest(deploymentName));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = RestClient.DeleteAtTenantScope(deploymentName, cancellationToken);
            return CreateDeleteAtTenantScope(originalResponse, () => RestClient.CreateDeleteAtTenantScopeRequest(deploymentName));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentExtended> CreateCreateOrUpdateAtTenantScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Put, "DeploymentsClient.CreateOrUpdateAtTenantScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            });
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentExtended>> StartCreateOrUpdateAtTenantScopeAsync(string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.CreateOrUpdateAtTenantScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateCreateOrUpdateAtTenantScope(originalResponse, () => RestClient.CreateCreateOrUpdateAtTenantScopeRequest(deploymentName, parameters));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentExtended> StartCreateOrUpdateAtTenantScope(string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.CreateOrUpdateAtTenantScope(deploymentName, parameters, cancellationToken);
            return CreateCreateOrUpdateAtTenantScope(originalResponse, () => RestClient.CreateCreateOrUpdateAtTenantScopeRequest(deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentValidateResult> CreateValidateAtTenantScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Post, "DeploymentsClient.ValidateAtTenantScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            });
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentValidateResult>> StartValidateAtTenantScopeAsync(string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.ValidateAtTenantScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateValidateAtTenantScope(originalResponse, () => RestClient.CreateValidateAtTenantScopeRequest(deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentValidateResult> StartValidateAtTenantScope(string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.ValidateAtTenantScope(deploymentName, parameters, cancellationToken);
            return CreateValidateAtTenantScope(originalResponse, () => RestClient.CreateValidateAtTenantScopeRequest(deploymentName, parameters));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAtManagementGroupScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Delete, "DeploymentsClient.DeleteAtManagementGroupScope", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = await RestClient.DeleteAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
            return CreateDeleteAtManagementGroupScope(originalResponse, () => RestClient.CreateDeleteAtManagementGroupScopeRequest(groupId, deploymentName));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = RestClient.DeleteAtManagementGroupScope(groupId, deploymentName, cancellationToken);
            return CreateDeleteAtManagementGroupScope(originalResponse, () => RestClient.CreateDeleteAtManagementGroupScopeRequest(groupId, deploymentName));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentExtended> CreateCreateOrUpdateAtManagementGroupScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Put, "DeploymentsClient.CreateOrUpdateAtManagementGroupScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            });
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentExtended>> StartCreateOrUpdateAtManagementGroupScopeAsync(string groupId, string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.CreateOrUpdateAtManagementGroupScopeAsync(groupId, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateCreateOrUpdateAtManagementGroupScope(originalResponse, () => RestClient.CreateCreateOrUpdateAtManagementGroupScopeRequest(groupId, deploymentName, parameters));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentExtended> StartCreateOrUpdateAtManagementGroupScope(string groupId, string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.CreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, cancellationToken);
            return CreateCreateOrUpdateAtManagementGroupScope(originalResponse, () => RestClient.CreateCreateOrUpdateAtManagementGroupScopeRequest(groupId, deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentValidateResult> CreateValidateAtManagementGroupScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Post, "DeploymentsClient.ValidateAtManagementGroupScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            });
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentValidateResult>> StartValidateAtManagementGroupScopeAsync(string groupId, string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.ValidateAtManagementGroupScopeAsync(groupId, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateValidateAtManagementGroupScope(originalResponse, () => RestClient.CreateValidateAtManagementGroupScopeRequest(groupId, deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentValidateResult> StartValidateAtManagementGroupScope(string groupId, string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.ValidateAtManagementGroupScope(groupId, deploymentName, parameters, cancellationToken);
            return CreateValidateAtManagementGroupScope(originalResponse, () => RestClient.CreateValidateAtManagementGroupScopeRequest(groupId, deploymentName, parameters));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDeleteAtSubscriptionScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Delete, "DeploymentsClient.DeleteAtSubscriptionScope", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = await RestClient.DeleteAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            return CreateDeleteAtSubscriptionScope(originalResponse, () => RestClient.CreateDeleteAtSubscriptionScopeRequest(deploymentName));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDeleteAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = RestClient.DeleteAtSubscriptionScope(deploymentName, cancellationToken);
            return CreateDeleteAtSubscriptionScope(originalResponse, () => RestClient.CreateDeleteAtSubscriptionScopeRequest(deploymentName));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentExtended> CreateCreateOrUpdateAtSubscriptionScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Put, "DeploymentsClient.CreateOrUpdateAtSubscriptionScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            });
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentExtended>> StartCreateOrUpdateAtSubscriptionScopeAsync(string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.CreateOrUpdateAtSubscriptionScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateCreateOrUpdateAtSubscriptionScope(originalResponse, () => RestClient.CreateCreateOrUpdateAtSubscriptionScopeRequest(deploymentName, parameters));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentExtended> StartCreateOrUpdateAtSubscriptionScope(string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.CreateOrUpdateAtSubscriptionScope(deploymentName, parameters, cancellationToken);
            return CreateCreateOrUpdateAtSubscriptionScope(originalResponse, () => RestClient.CreateCreateOrUpdateAtSubscriptionScopeRequest(deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentValidateResult> CreateValidateAtSubscriptionScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Post, "DeploymentsClient.ValidateAtSubscriptionScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            });
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentValidateResult>> StartValidateAtSubscriptionScopeAsync(string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.ValidateAtSubscriptionScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateValidateAtSubscriptionScope(originalResponse, () => RestClient.CreateValidateAtSubscriptionScopeRequest(deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentValidateResult> StartValidateAtSubscriptionScope(string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.ValidateAtSubscriptionScope(deploymentName, parameters, cancellationToken);
            return CreateValidateAtSubscriptionScope(originalResponse, () => RestClient.CreateValidateAtSubscriptionScopeRequest(deploymentName, parameters));
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the subscription. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<WhatIfOperationResult> CreateWhatIfAtSubscriptionScope(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Post, "DeploymentsClient.WhatIfAtSubscriptionScope", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return WhatIfOperationResult.DeserializeWhatIfOperationResult(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return WhatIfOperationResult.DeserializeWhatIfOperationResult(document.RootElement);
                }
            });
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the subscription. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="properties"> The deployment properties. </param>
        /// <param name="location"> The location to store the deployment data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<WhatIfOperationResult>> StartWhatIfAtSubscriptionScopeAsync(string deploymentName, DeploymentWhatIfProperties properties, string location = null, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (properties == null)
            {
                throw new ArgumentNullException(nameof(properties));
            }

            var originalResponse = await RestClient.WhatIfAtSubscriptionScopeAsync(deploymentName, properties, location, cancellationToken).ConfigureAwait(false);
            return CreateWhatIfAtSubscriptionScope(originalResponse, () => RestClient.CreateWhatIfAtSubscriptionScopeRequest(deploymentName, properties, location));
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the subscription. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="properties"> The deployment properties. </param>
        /// <param name="location"> The location to store the deployment data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<WhatIfOperationResult> StartWhatIfAtSubscriptionScope(string deploymentName, DeploymentWhatIfProperties properties, string location = null, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (properties == null)
            {
                throw new ArgumentNullException(nameof(properties));
            }

            var originalResponse = RestClient.WhatIfAtSubscriptionScope(deploymentName, properties, location, cancellationToken);
            return CreateWhatIfAtSubscriptionScope(originalResponse, () => RestClient.CreateWhatIfAtSubscriptionScopeRequest(deploymentName, properties, location));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<Response> CreateDelete(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Delete, "DeploymentsClient.Delete", OperationFinalStateVia.Location, createOriginalHttpMessage);
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployment to delete. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<Response>> StartDeleteAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = await RestClient.DeleteAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
            return CreateDelete(originalResponse, () => RestClient.CreateDeleteRequest(resourceGroupName, deploymentName));
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployment to delete. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<Response> StartDelete(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            var originalResponse = RestClient.Delete(resourceGroupName, deploymentName, cancellationToken);
            return CreateDelete(originalResponse, () => RestClient.CreateDeleteRequest(resourceGroupName, deploymentName));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentExtended> CreateCreateOrUpdate(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Put, "DeploymentsClient.CreateOrUpdate", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentExtended.DeserializeDeploymentExtended(document.RootElement);
                }
            });
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="resourceGroupName"> The name of the resource group to deploy the resources to. The name is case insensitive. The resource group must already exist. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentExtended>> StartCreateOrUpdateAsync(string resourceGroupName, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.CreateOrUpdateAsync(resourceGroupName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateCreateOrUpdate(originalResponse, () => RestClient.CreateCreateOrUpdateRequest(resourceGroupName, deploymentName, parameters));
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="resourceGroupName"> The name of the resource group to deploy the resources to. The name is case insensitive. The resource group must already exist. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentExtended> StartCreateOrUpdate(string resourceGroupName, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.CreateOrUpdate(resourceGroupName, deploymentName, parameters, cancellationToken);
            return CreateCreateOrUpdate(originalResponse, () => RestClient.CreateCreateOrUpdateRequest(resourceGroupName, deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<DeploymentValidateResult> CreateValidate(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Post, "DeploymentsClient.Validate", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return DeploymentValidateResult.DeserializeDeploymentValidateResult(document.RootElement);
                }
            });
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="resourceGroupName"> The name of the resource group the template will be deployed to. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<DeploymentValidateResult>> StartValidateAsync(string resourceGroupName, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = await RestClient.ValidateAsync(resourceGroupName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
            return CreateValidate(originalResponse, () => RestClient.CreateValidateRequest(resourceGroupName, deploymentName, parameters));
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="resourceGroupName"> The name of the resource group the template will be deployed to. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<DeploymentValidateResult> StartValidate(string resourceGroupName, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            var originalResponse = RestClient.Validate(resourceGroupName, deploymentName, parameters, cancellationToken);
            return CreateValidate(originalResponse, () => RestClient.CreateValidateRequest(resourceGroupName, deploymentName, parameters));
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the resource group. </summary>
        /// <param name="originalResponse"> The original response from starting the operation. </param>
        /// <param name="createOriginalHttpMessage"> Creates the HTTP message used for the original request. </param>
        internal Operation<WhatIfOperationResult> CreateWhatIf(Response originalResponse, Func<Core.HttpMessage> createOriginalHttpMessage)
        {
            if (originalResponse == null)
            {
                throw new ArgumentNullException(nameof(originalResponse));
            }
            if (createOriginalHttpMessage == null)
            {
                throw new ArgumentNullException(nameof(createOriginalHttpMessage));
            }

            return ArmOperationHelpers.Create(_pipeline, _clientDiagnostics, originalResponse, RequestMethod.Post, "DeploymentsClient.WhatIf", OperationFinalStateVia.Location, createOriginalHttpMessage,
            (response, cancellationToken) =>
            {
                using var document = JsonDocument.Parse(response.ContentStream);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return WhatIfOperationResult.DeserializeWhatIfOperationResult(document.RootElement);
                }
            },
            async (response, cancellationToken) =>
            {
                using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                if (document.RootElement.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                else
                {
                    return WhatIfOperationResult.DeserializeWhatIfOperationResult(document.RootElement);
                }
            });
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the resource group. </summary>
        /// <param name="resourceGroupName"> The name of the resource group the template will be deployed to. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="properties"> The deployment properties. </param>
        /// <param name="location"> The location to store the deployment data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<Operation<WhatIfOperationResult>> StartWhatIfAsync(string resourceGroupName, string deploymentName, DeploymentWhatIfProperties properties, string location = null, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (properties == null)
            {
                throw new ArgumentNullException(nameof(properties));
            }

            var originalResponse = await RestClient.WhatIfAsync(resourceGroupName, deploymentName, properties, location, cancellationToken).ConfigureAwait(false);
            return CreateWhatIf(originalResponse, () => RestClient.CreateWhatIfRequest(resourceGroupName, deploymentName, properties, location));
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the resource group. </summary>
        /// <param name="resourceGroupName"> The name of the resource group the template will be deployed to. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="properties"> The deployment properties. </param>
        /// <param name="location"> The location to store the deployment data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Operation<WhatIfOperationResult> StartWhatIf(string resourceGroupName, string deploymentName, DeploymentWhatIfProperties properties, string location = null, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (properties == null)
            {
                throw new ArgumentNullException(nameof(properties));
            }

            var originalResponse = RestClient.WhatIf(resourceGroupName, deploymentName, properties, location, cancellationToken);
            return CreateWhatIf(originalResponse, () => RestClient.CreateWhatIfRequest(resourceGroupName, deploymentName, properties, location));
        }
    }
}
